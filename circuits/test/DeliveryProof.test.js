/**
 * DeliveryProof Circuit Tests
 *
 * These tests verify the correct operation of the DeliveryProof.circom circuit.
 * The circuit proves knowledge of a secret that hashes to a known value.
 */

const { wasm, zkey } = require("snarkjs");
const path = require("path");
const { buildPoseidon } = require("circomlibjs");
const assert = require("assert");

// Paths to circuit artifacts (generated by `npm run compile` and `npm run setup`)
const WASM_PATH = path.join(__dirname, "../build/DeliveryProof_js/DeliveryProof.wasm");
const ZKEY_PATH = path.join(__dirname, "../build/DeliveryProof_final.zkey");
const VKEY_PATH = path.join(__dirname, "../build/verification_key.json");

// BN254 field prime
const FIELD_PRIME = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");

let poseidon;
let poseidonF;

/**
 * Setup function to initialize Poseidon hasher
 */
async function setup() {
  poseidon = await buildPoseidon();
  poseidonF = poseidon.F;
}

/**
 * Compute Poseidon hash of inputs
 */
function hash(inputs) {
  const h = poseidon(inputs);
  return poseidonF.toObject(h);
}

/**
 * Generate a random field element
 */
function randomFieldElement() {
  const bytes = new Uint8Array(31);
  require("crypto").randomFillSync(bytes);
  let value = BigInt(0);
  for (let i = 0; i < bytes.length; i++) {
    value = (value << BigInt(8)) | BigInt(bytes[i]);
  }
  return value % FIELD_PRIME;
}

describe("DeliveryProof Circuit", function () {
  // Increase timeout for proof generation
  this.timeout(60000);

  before(async function () {
    await setup();
  });

  // ============ TEST 1: Valid proof with correct secret ============

  it("generates valid proof with correct secret", async function () {
    // Generate test data
    const secret = randomFieldElement();
    const secretHash = hash([secret]);
    const orderId = BigInt(12345);
    const courierAddress = BigInt("0x1234567890123456789012345678901234567890");

    // Create input
    const input = {
      secret: secret.toString(),
      secretHash: secretHash.toString(),
      orderId: orderId.toString(),
      courierAddress: courierAddress.toString(),
    };

    // Generate proof
    const { proof, publicSignals } = await wasm.groth16FullProve(
      input,
      WASM_PATH,
      ZKEY_PATH
    );

    // Verify proof structure
    assert(proof.pi_a, "Proof should have pi_a");
    assert(proof.pi_b, "Proof should have pi_b");
    assert(proof.pi_c, "Proof should have pi_c");

    // Verify public signals
    assert.strictEqual(publicSignals.length, 4, "Should have 4 public signals");
    // Order: valid, secretHash, orderId, courierAddress
    assert.strictEqual(publicSignals[0], "1", "Valid signal should be 1");
    assert.strictEqual(publicSignals[1], secretHash.toString(), "secretHash should match");
    assert.strictEqual(publicSignals[2], orderId.toString(), "orderId should match");
    assert.strictEqual(publicSignals[3], courierAddress.toString(), "courierAddress should match");

    // Verify proof is valid
    const vkey = require(VKEY_PATH);
    const isValid = await wasm.groth16Verify(vkey, publicSignals, proof);
    assert.strictEqual(isValid, true, "Proof should be valid");
  });

  // ============ TEST 2: Proof fails with incorrect secret ============

  it("fails with incorrect secret", async function () {
    // Generate test data
    const secret = randomFieldElement();
    const secretHash = hash([secret]);
    const wrongSecret = randomFieldElement(); // Different secret
    const orderId = BigInt(12345);
    const courierAddress = BigInt("0x1234567890123456789012345678901234567890");

    // Ensure wrong secret is actually different
    assert.notStrictEqual(
      wrongSecret.toString(),
      secret.toString(),
      "Wrong secret should be different"
    );

    // Create input with wrong secret
    const input = {
      secret: wrongSecret.toString(), // Wrong!
      secretHash: secretHash.toString(),
      orderId: orderId.toString(),
      courierAddress: courierAddress.toString(),
    };

    // Attempt to generate proof - should fail due to constraint
    try {
      await wasm.groth16FullProve(input, WASM_PATH, ZKEY_PATH);
      assert.fail("Should have thrown an error for wrong secret");
    } catch (error) {
      // Expected: constraint not satisfied
      assert(
        error.message.includes("Assert Failed") ||
          error.message.includes("constraint") ||
          error.message.includes("Error"),
        `Expected constraint error, got: ${error.message}`
      );
    }
  });

  // ============ TEST 3: Hash consistency ============

  it("circuit Poseidon matches JS Poseidon", async function () {
    // Test multiple values for consistency
    const testCases = [
      BigInt(0),
      BigInt(1),
      BigInt(12345),
      randomFieldElement(),
      randomFieldElement(),
    ];

    for (const secret of testCases) {
      const jsHash = hash([secret]);

      // The circuit computes Poseidon(secret) internally
      // We verify by generating a valid proof with matching hash
      const input = {
        secret: secret.toString(),
        secretHash: jsHash.toString(),
        orderId: "1",
        courierAddress: "1",
      };

      // If proof generation succeeds, the hashes match
      const { publicSignals } = await wasm.groth16FullProve(
        input,
        WASM_PATH,
        ZKEY_PATH
      );

      assert.strictEqual(
        publicSignals[1],
        jsHash.toString(),
        `Hash mismatch for secret ${secret}`
      );
    }
  });

  // ============ TEST 4: Proof binds to order ID ============

  it("proof is bound to specific orderId", async function () {
    const secret = randomFieldElement();
    const secretHash = hash([secret]);
    const orderId1 = BigInt(100);
    const orderId2 = BigInt(200);
    const courierAddress = BigInt("0x1234567890123456789012345678901234567890");

    // Generate proof for order 1
    const input1 = {
      secret: secret.toString(),
      secretHash: secretHash.toString(),
      orderId: orderId1.toString(),
      courierAddress: courierAddress.toString(),
    };

    const { proof: proof1, publicSignals: signals1 } = await wasm.groth16FullProve(
      input1,
      WASM_PATH,
      ZKEY_PATH
    );

    // Generate proof for order 2
    const input2 = {
      secret: secret.toString(),
      secretHash: secretHash.toString(),
      orderId: orderId2.toString(),
      courierAddress: courierAddress.toString(),
    };

    const { proof: proof2, publicSignals: signals2 } = await wasm.groth16FullProve(
      input2,
      WASM_PATH,
      ZKEY_PATH
    );

    // Public signals should differ in orderId
    assert.notStrictEqual(
      signals1[2],
      signals2[2],
      "Order IDs in public signals should differ"
    );

    // Verify both proofs are valid individually
    const vkey = require(VKEY_PATH);
    assert.strictEqual(
      await wasm.groth16Verify(vkey, signals1, proof1),
      true,
      "Proof1 should be valid"
    );
    assert.strictEqual(
      await wasm.groth16Verify(vkey, signals2, proof2),
      true,
      "Proof2 should be valid"
    );

    // Cross-verification should fail (proof1 with signals2)
    assert.strictEqual(
      await wasm.groth16Verify(vkey, signals2, proof1),
      false,
      "Proof1 should not verify with signals2"
    );
  });

  // ============ TEST 5: Proof binds to courier address ============

  it("proof is bound to specific courierAddress", async function () {
    const secret = randomFieldElement();
    const secretHash = hash([secret]);
    const orderId = BigInt(100);
    const courier1 = BigInt("0x1111111111111111111111111111111111111111");
    const courier2 = BigInt("0x2222222222222222222222222222222222222222");

    // Generate proof for courier 1
    const input1 = {
      secret: secret.toString(),
      secretHash: secretHash.toString(),
      orderId: orderId.toString(),
      courierAddress: courier1.toString(),
    };

    const { proof: proof1, publicSignals: signals1 } = await wasm.groth16FullProve(
      input1,
      WASM_PATH,
      ZKEY_PATH
    );

    // Generate proof for courier 2
    const input2 = {
      secret: secret.toString(),
      secretHash: secretHash.toString(),
      orderId: orderId.toString(),
      courierAddress: courier2.toString(),
    };

    const { proof: proof2, publicSignals: signals2 } = await wasm.groth16FullProve(
      input2,
      WASM_PATH,
      ZKEY_PATH
    );

    // Public signals should differ in courierAddress
    assert.notStrictEqual(
      signals1[3],
      signals2[3],
      "Courier addresses in public signals should differ"
    );

    // Cross-verification should fail
    const vkey = require(VKEY_PATH);
    assert.strictEqual(
      await wasm.groth16Verify(vkey, signals2, proof1),
      false,
      "Proof1 should not verify with courier2's signals"
    );
  });

  // ============ TEST 6: Zero secret is valid ============

  it("handles zero secret correctly", async function () {
    const secret = BigInt(0);
    const secretHash = hash([secret]);
    const orderId = BigInt(1);
    const courierAddress = BigInt(1);

    const input = {
      secret: "0",
      secretHash: secretHash.toString(),
      orderId: orderId.toString(),
      courierAddress: courierAddress.toString(),
    };

    const { proof, publicSignals } = await wasm.groth16FullProve(
      input,
      WASM_PATH,
      ZKEY_PATH
    );

    const vkey = require(VKEY_PATH);
    const isValid = await wasm.groth16Verify(vkey, publicSignals, proof);
    assert.strictEqual(isValid, true, "Zero secret proof should be valid");
  });

  // ============ TEST 7: Large secret near field prime ============

  it("handles large secret near field prime", async function () {
    // Use a value close to but under the field prime
    const secret = FIELD_PRIME - BigInt(1);
    const secretHash = hash([secret]);
    const orderId = BigInt(1);
    const courierAddress = BigInt(1);

    const input = {
      secret: secret.toString(),
      secretHash: secretHash.toString(),
      orderId: orderId.toString(),
      courierAddress: courierAddress.toString(),
    };

    const { proof, publicSignals } = await wasm.groth16FullProve(
      input,
      WASM_PATH,
      ZKEY_PATH
    );

    const vkey = require(VKEY_PATH);
    const isValid = await wasm.groth16Verify(vkey, publicSignals, proof);
    assert.strictEqual(isValid, true, "Large secret proof should be valid");
  });
});

// Run tests if executed directly
if (require.main === module) {
  const Mocha = require("mocha");
  const mocha = new Mocha();

  mocha.addFile(__filename);
  mocha.run((failures) => {
    process.exitCode = failures ? 1 : 0;
  });
}
